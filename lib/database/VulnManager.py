#!/usr/bin/env python3.3
# -*- coding: utf-8 -*-
#
# Interface for the database connection
#
# Copyright (c) 2014-2015 	Pieter-Jan Moreels
#
# Software is free software released under the "Original BSD license"

# Imports
import itertools
import re
import time

from lib.Config import Configuration as conf
from lib.VulnManager import SystemGroup, Component, Ticket
from lib.database.CVESearch import getVulns, getCVEInfo, isVulnerable

# Variables
vmdb = conf.getVMMongoConnection()
# Collections
systems=vmdb.systems
components = vmdb.components
tickets = vmdb.tickets

# ADD
def addSystemGroup(group):
  if type(group) is not SystemGroup: return False
  j=group.getDict()
  try:
    count=systems.find({"groupName":j["groupName"], "team":j["team"]}).count()
    if count > 0: raise(alreadyExistsException)
    if j["team"]==None:
      count=systems.find({"groupName":j["groupName"], "team":{"$ne":None}}).count()
      if count > 0: raise(teamRequiredException)
    systems.insert(group.getDict())
    return True
  except Exception as e:
    print(e)
    return False

def addComponent(component):
  if type(component) is not Component: return False
  j=component.getDict()
  if components.find({ "$or":[{'name':j['name']},{'cpe':j['cpe']}]}).count() > 0:
    return False
  else:
    components.insert(j)
    return True

def addTicket(ticket):
  if type(ticket) is not Ticket: return False
  t=ticket.getDict()
  if tickets.find({"team":t["team"], "groupName":t["groupName"], "cve":t["cve"]}).count() > 0:
    return False
  else:
    tickets.insert(t)
    return True
  
# GET
def getGroups(team):
  c = list(systems.find({"team":team}).sort("groupName", 1))
  for x in c: x.pop('_id')
  for x in c:
    for comp in x["components"]:
      vuln=isVulnerable(comp["cpe"])
      if vuln: x["vulnerable"]=True
      comp["vulnerable"]=vuln
  return sorted(c, key=lambda s: s["groupName"].lower())

def getComponents():
  c = list(components.find().sort("name", 1))
  for x in c: x.pop('_id')
  return sorted(c, key=lambda s: s["name"].lower())

def getComponent(cpe, system=None, team=None):
  if system and team:
    c = [x for x in systems.find_one({"team":team, "groupName":system})["components"] if x["cpe"] == cpe]
    if c: c=c[0]
  else:
    c = components.find_one({"cpe":cpe})
  if '_id' in c: c.pop('_id')
  return c

def getCPEs(team):
  vulns=getGroups(team)
  cpes=[[x["cpe"] for x in vuln["components"]] for vuln in vulns]
  return list(set(itertools.chain(*cpes)))

def getLastTeamVulns(team, limit):
  return getVulns(getCPEs(team), limit)

def getVulnsForSystem(groupName, systemTeam, cpes=None):
  if type(cpes) is not list and cpes:cpes=[cpes]
  if not cpes: cpes=[x["cpe"] for x in systems.find_one({"team":systemTeam, "groupName":groupName})["components"]]
  
  vulns=[x["id"] for x in getVulns(cpes, 0)]
  # Get tickets for every cve for the vulnerable systems
  tickets=[getTicket(cve, groupName, systemTeam) for cve in [x["id"] for x in getVulns(cpes, 0)]]
  # Take out the completed tickets
  tickets=[x for x in tickets if not x["status"].lower().startswith("completed")]
  return tickets

def getTicket(cve, system, team):
  t=tickets.find_one({"team":team, "groupName":system, "cve":cve})
  if not t:
    tick=Ticket(team, system, cve, conf.getTicketDefaultValue())
    addTicket(tick)
    t=tick.getDict()
  t["cve"]=getCVEInfo(cve)
  return t

# UPDATE
def setDBTicketNotes(ticket, user, notes):
  t=ticket.getDict()
  if "notes" in t and t["notes"] == notes.strip(): return False
  history={"time": int(time.time()*10000000), "user":user, "notes": notes}
  tickets.update({"team":t["team"], "groupName":t["groupName"], "cve":t["cve"]},{"$set":{"notes": notes.strip()}, "$addToSet":{"history":history}})
  return True

def setDBTicketStatus(ticket, user, status):
  t=ticket.getDict()
  if t["status"] == status.strip(): return False
  history={"time": int(time.time()*10000000), "user":user, "status": status}
  tickets.update({"team":t["team"], "groupName":t["groupName"], "cve":t["cve"]},{"$set":{"status": status.strip()}, "$addToSet":{"history":history}})
  return True

# EXCEPTIONS
class teamRequiredException(Exception):
  pass
class alreadyExistsException(Exception):
  pass
